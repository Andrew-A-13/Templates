template<const int MAXV, const int ALL_PRIMES = 78498>
class factorization_sieve_t {
private:
    array<int, ALL_PRIMES> primes;
    array<int, MAXV + 1> min_prime_divisor;

    void build_sieve() {
        int last_prime = -1;
        min_prime_divisor[1] = 1;
        for (int i = 2; i < MAXV + 1; ++i) {
            if (!min_prime_divisor[i]) {
                assert(++last_prime < ALL_PRIMES);
                primes[last_prime] = min_prime_divisor[i] = i;
            }

            // k = min_p_div[k] * i => for every i let's look at primes, which are less than min_p_div[i].
            // this way we will get such numbers x, that x = prime * i, where prime <= min_p_div[i], so min_p_div[x] = prime
            // Genius!
            for (int pos = 0; pos <= last_prime && primes[pos] <= min_prime_divisor[i] && i * primes[pos] < MAXV + 1; ++pos) {
                min_prime_divisor[i * primes[pos]] = primes[pos];
            }
        }

        if (last_prime + 1 < ALL_PRIMES) {
            cerr << "Be careful, found primes less than ALL_PRIMES, so u are able to optimize code!" << endl
                << "found primes: " << last_prime + 1 << ", ALL_PRIMES = " << ALL_PRIMES << endl;
        }
    }

public:

    /*u should use it to find ALL_PRIMES
     * for e.g.:
     *  1st execution:
     *      cout << factorization_sieve_t<MAXV>::count_primes_amount(); (copy printed value)
     *  2nd execution:
     *      const int ALL_PRIMES = *copied value*;
     *      factorization_sieve_t<MAXV, ALL_PRIMES> sieve;
     */
    static int count_primes_amount() {
        int primes_amount = 0;
        array<bool, MAXV + 1> is_prime;
        fill(all(is_prime), true);
        for (int i = 2; i < MAXV + 1; ++i) {
            if (!is_prime[i]) {
                continue;
            }

            ++primes_amount;
            for (int j = 2 * i; j < MAXV + 1; j += i) {
                is_prime[j] = false;
            }
        }

        return primes_amount;
    }

    factorization_sieve_t() : min_prime_divisor() {
        build_sieve();
    }

    const array<int, MAXV + 1>& get_min_prime_divisors() const {
        return min_prime_divisor;
    }

    int get_min_prime_divisor(int x) const {
        return min_prime_divisor[x];
    }

    // returns vector of { {a prime number, power of the prime number} } in inc order
    vector<pair<int, int>> get_factorization_as_pairs(int x) {
        vector<pair<int, int>> factorization;
        while (x != 1) {
            const int mpd = get_min_prime_divisor(x);
            if (factorization.empty() || factorization.back().first != mpd) {
                factorization.emplace_back(mpd, 1);
            }
            else {
                ++factorization.back().second;
            }

            x /= mpd;
        }

        return factorization;
    }

    // returns dict of { {key: a prime number, value: power of the prime number} }
    template<typename T = map<int, int>>
    T get_factorization_as_dict(int x) {
        T ret;
        for (auto& [factor, cnt] : get_factorization_as_pairs(x)) {
            ret[factor] = cnt;
        }
        return ret;
    }

    const array<int, ALL_PRIMES>& get_all_primes() const {
        return primes;
    }

    bool is_prime(int x) const {
        return x != 1 && min_prime_divisor[x] == x;
    }
};

const int MAXN = 1'000'000;
factorization_sieve_t<MAXN> sieve;
